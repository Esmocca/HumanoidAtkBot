/*
 * ========================================
 * ROBOT BATTLE SYSTEM - RASPBERRY PI PICO W
 * ========================================
 * Handcombat stance
 * Client Name: Griffith
 * Update: Auto-Discovery Server via mDNS
 * ========================================
 */

#include <WiFi.h>
#include <Wire.h>
#include <Adafruit_PWMServoDriver.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

// PCA9585
#define SERVO_MIN 150  // Posisi minimum servo
#define SERVO_MAX 600  // Posisi maksimum servo
Adafruit_PWMServoDriver pwm = Adafruit_PWMServoDriver(0x40);

// OLED
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET    -1
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire1, -1);

// Definisi kanal untuk masing-masing servo
#define SERVO_PUNGGUNG 0
#define SERVO_BAHUKANAN 1
#define SERVO_TANGANKIRI 2
#define SERVO_SIKUKANAN 3
#define SERVO_PINGGANG 4
#define SERVO_KAKIKANAN 5
#define SERVO_KAKIKIRI 6
#define SERVO_LUTUTKANAN 7
#define SERVO_LUTUTKIRI 8
#define SERVO_TELAPAKKANAN 9
#define SERVO_TELAPAKKIRI 10

// Konfigurasi Wi-Fi
const char* ssid = "Alamak";
const char* password = "ndaktaukoktanyasaya";

// Server Discovery Configuration
const char* serverMdnsName = "robot-server";  // Hostname server (harus sama dengan server)
const int serverPort = 50003;

// Konfigurasi Klien
const String clientName = "Esmocca"; // Ganti untuk client kedua

// Server connection variables
char serverIP[16] = "";  // Buffer untuk IP server yang ditemukan
bool serverFound = false;
unsigned long lastDiscoveryTime = 0;
const unsigned long DISCOVERY_INTERVAL = 10000;  // Coba discover setiap 10 detik jika belum connected

// Status robot
int hp = 400;
int atk = 30;
int defense = 30;
int strength = 10;
int energy = 150;
const int energyMax = 150;
const int energyRegen = 40;
const unsigned long energyInterval = 5000;
bool robotAlive = true;
int hpstats = hp;

// Button pins
const int skillPin = 12;
const int resetPin = 13;
const int atkPin = 14;
const int blockPin = 15;

// Block button
int block_press_count = 0;
int block_state = 0;
int prev_block_state = 0;
unsigned long lastBlockTime = 0, blockInterval = 3000;
bool isBlocking = false;

// Attack button
int button_state = 0;
unsigned long lastAtkTime = 0, atkInterval = 500;
bool isAttacking = false;

// Skill button
int skill_state = 0;
unsigned long lastSkill = 0, skillInterval = 500;
bool isSkill = false;

// Timing Variables
unsigned long lastRegen = 0;
unsigned long lastAttack = 0;
bool skillReleased = true;
bool atkReleased = true;

// Variabel untuk animasi
int hitAnimationIndex = 0;
int defeatAnimationStep = 0;
unsigned long defeatMotionStart = 0;
bool isHitAnimating = false;
unsigned long hitAnimationStart = 0;
bool blockingAtkMotionActive = false;
unsigned long blockingAtkMotionStart = 0;

WiFiClient client;

// Fungsi untuk discover server menggunakan mDNS
bool discoverServer() {
  Serial.println("Discovering robot-server via mDNS...");
  displayPrint("Discovering\nserver...");
  
  // Create hostname string dan IPAddress untuk hasil
  String hostnameStr = String(serverMdnsName) + ".local";
  IPAddress serverAddress;
  
  // Resolve hostname ke IP address (parameter: hostname, reference to IPAddress)
  int result = WiFi.hostByName(hostnameStr.c_str(), serverAddress);
  
  if (result != 0 && serverAddress != (uint32_t)0) {
    // Konversi IPAddress ke string
    sprintf(serverIP, "%d.%d.%d.%d", serverAddress[0], serverAddress[1], 
            serverAddress[2], serverAddress[3]);
    
    serverFound = true;
    Serial.print("Server found at: ");
    Serial.println(serverIP);
    displayPrint("Server found!\n" + String(serverIP));
    delay(1500);
    return true;
  } else {
    Serial.println("Server not found");
    displayPrint("Server not\nfound...");
    delay(1000);
    return false;
  }
}

void setup() {
  Serial.begin(115200);

  // Inisialisasi OLED
  Wire1.setSDA(18);
  Wire1.setSCL(19);
  Wire1.begin();

  if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { 
    Serial.println("OLED Gagal");
    while(1);
  }

  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(WHITE);

  Wire.setSDA(20);
  Wire.setSCL(21);
  Wire.begin();
  pwm.begin();
  pwm.setPWMFreq(50);

  // Inisialisasi Pin
  pinMode(atkPin, INPUT_PULLUP);
  pinMode(blockPin, INPUT_PULLUP);
  pinMode(resetPin, INPUT_PULLUP);
  pinMode(skillPin, INPUT_PULLUP);

  setIdlePosition();
  connectToWiFi();
  
  // Mulai discovery server
  displayPrint("Searching for\nserver...");
  int discoveryAttempts = 0;
  while (!serverFound && discoveryAttempts < 5) {
    if (discoverServer()) {
      break;
    }
    discoveryAttempts++;
    delay(1000);
  }
  
  if (serverFound) {
    connectToServer();
  } else {
    displayPrint("Server not found!\nRetry in loop...");
    delay(2000);
  }
}

void setServoAngle(uint8_t servo, int angle) {
  int pulse = map(angle, 0, 180, SERVO_MIN, SERVO_MAX);
  pwm.setPWM(servo, 0, pulse);
}

void updateDisplay() {
  display.clearDisplay();
  display.setTextColor(WHITE);
  display.setTextSize(1);
  display.setCursor(10, 0);
  display.println(clientName);
  display.println("HP: " + String(hp));
  display.println("ATK: " + String(atk));
  display.println("DEF: " + String(defense) + "%");
  display.println("STR: " + String(strength) + "%");
  display.println("ENGY: " + String(energy));
  display.display();
}

void displayPrint(const String &text) {
  display.setTextColor(WHITE);
  display.setTextSize(1);
  Serial.println(text);
  display.clearDisplay();
  display.setCursor(0,0);
  display.println(text);
  display.display();
}

void connectToWiFi() {
  Serial.println("Connecting to WiFi...");
  displayPrint("Connecting to\nWiFi...");
  WiFi.begin(ssid, password);
  
  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 20) {
    delay(500);
    Serial.print(".");
    attempts++;
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    displayPrint("WiFi Connected!\nIP: " + WiFi.localIP().toString());
    Serial.println("\nWiFi Connected!");
    delay(2000);
  } else {
    displayPrint("WiFi Failed!\nCheck SSID/Pass");
    delay(2000);
  }
}

void connectToServer() {
  if (!serverFound) {
    displayPrint("Server IP unknown");
    return;
  }
  
  displayPrint("Connecting to\nserver...");
  int attempts = 0;
  
  while (!client.connect(serverIP, serverPort) && attempts < 5) {
    Serial.println("Connection failed, retrying...");
    displayPrint("Connection\nfailed...");
    delay(1000);
    attempts++;
  }
  
  if (client.connected()) {
    client.println(clientName);
    displayPrint("Server Connected!");
    Serial.println("Server Connected!");
    delay(1500);
  } else {
    displayPrint("Server connect\nfailed!");
    Serial.println("Failed to connect to server");
    delay(2000);
  }
}

void handleServer() {
  // Jika client belum connected dan server sudah ditemukan, coba connect
  if (!client.connected() && serverFound) {
    // Coba rediscover dan reconnect setiap 10 detik
    if (millis() - lastDiscoveryTime > DISCOVERY_INTERVAL) {
      lastDiscoveryTime = millis();
      Serial.println("Attempting to reconnect to server...");
      connectToServer();
    }
    return;
  }
  
  // Jika server belum ditemukan sama sekali
  if (!serverFound) {
    if (millis() - lastDiscoveryTime > DISCOVERY_INTERVAL) {
      lastDiscoveryTime = millis();
      discoverServer();
      if (serverFound) {
        connectToServer();
      }
    }
    return;
  }
  
  // Proses data dari server
  while (client.available()) {
    String data = client.readStringUntil('\n');
    data.trim();
    Serial.println("Received: " + data);
    
    if (data.startsWith("Atk")) {
      int incomingDamage = data.substring(4).toInt();
      handleDamage(incomingDamage);
    } else if (data.startsWith("Buff")) {
      handleBuff(data);
    }
  }
}

void setIdlePosition() {
  setServoAngle(SERVO_BAHUKANAN, 80);
  setServoAngle(SERVO_SIKUKANAN, 60);
  setServoAngle(SERVO_TANGANKIRI, 110);
  setServoAngle(SERVO_PUNGGUNG, 75);
  setServoAngle(SERVO_PINGGANG, 40);
  setServoAngle(SERVO_KAKIKANAN, 80);
  setServoAngle(SERVO_KAKIKIRI, 15);
  setServoAngle(SERVO_LUTUTKANAN , 10);
  setServoAngle(SERVO_LUTUTKIRI , 130);
  setServoAngle(SERVO_TELAPAKKANAN , 65);
  setServoAngle(SERVO_TELAPAKKIRI , 80);
}

bool debounceButton(int pin) {
  static unsigned long lastDebounceTime = 0;
  static int lastButtonState = LOW;
  int currentState = digitalRead(pin);

  if (currentState != lastButtonState) {
    lastDebounceTime = millis();
  }

  if ((millis() - lastDebounceTime) > 50) {
    if (currentState != button_state) {
      button_state = currentState;
    }
  }

  lastButtonState = currentState;
  return button_state == HIGH;
}

void handleEnergy() {
  if (millis() - lastRegen >= energyInterval) {
    energy = min(energy + energyRegen, energyMax);
    lastRegen = millis();
  }
}

void handleBuff(const String& command) {
  if (command.indexOf("HP") > 0) {
    hp = hp + hp / 10;
    hpstats = hp;
    Serial.println("HP Buffed +10%");
    displayPrint("HP Buff +10%");
  } else if (command.indexOf("ATK") > 0) {
    atk = atk + atk / 10;
    Serial.println("ATK Buffed +10%");
    displayPrint("ATK Buff +10%");
  } else if (command.indexOf("DEF") > 0) {
    defense = defense + defense / 10;
    Serial.println("DEF Buffed +10%");
    displayPrint("DEF Buff +10%");
  } else if (command.indexOf("STR") > 0) {
    strength = strength + strength / 10;
    Serial.println("STR Buffed +10%");
    displayPrint("STR Buff +10%");
  } else if (command.indexOf("ENGY") > 0) {
    energy = energy + energy / 10;
    energy = min(energy, energyMax);
    Serial.println("Energy Buffed +10%");
    displayPrint("ENGY Buff +10%");
  }
}

void handleDamage(int damage) {
  if (!robotAlive) return;

  if (isBlocking && energy > 0) {
    Serial.println("Attack Blocked!");
    energy = max(energy - 5, 0);
    handleBlockAtkmotion();
    return;
  } else {
    isBlocking = false;
  }

  int TotalDamage = damage - (damage * defense / 100);
  
  hp = max(hp - TotalDamage, 0);
  if (hp <= 0) {
    handleDefeat();
  } else {
    hitAnimationIndex = (hitAnimationIndex + 1) % 3;
    isHitAnimating = true;
    hitAnimationStart = millis();
  }
}

void handleHitMotion() {
  if(!isHitAnimating) return;

  unsigned long currentTime = millis();
  switch(hitAnimationIndex) {
    case 0:
    if(currentTime - hitAnimationStart > 200) {
    setServoAngle(SERVO_PINGGANG, 80);
    setServoAngle(SERVO_TANGANKIRI, 120);
    Serial.println("Hit motion 1");
    delay(50);
    }
    if(currentTime - hitAnimationStart > 300) {
      setIdlePosition();
      isHitAnimating = false;
    }
    break;

    case 1:
    if(currentTime - hitAnimationStart > 200) {
    setServoAngle(SERVO_PINGGANG, 20);
    setServoAngle(SERVO_TANGANKIRI, 120);
    Serial.println("Hit motion 2");
    delay(50);
    }
    if(currentTime - hitAnimationStart > 300) {
      setIdlePosition();
      isHitAnimating = false;
    }
    break;

    case 2:
    if(currentTime - hitAnimationStart > 200) {
    setServoAngle(SERVO_PINGGANG, 20);
    setServoAngle(SERVO_KAKIKANAN, 180);
    Serial.println("Hit motion 3");
    delay(50);
    }
    if(currentTime - hitAnimationStart > 300) {
      setIdlePosition();
      isHitAnimating = false;
    }
    break;
  }
}

void handleBlockAtkmotion() {
  if(!blockingAtkMotionActive) {
    blockingAtkMotionActive = true;
    blockingAtkMotionStart = millis();
  }
  unsigned long currentTime = millis();
  if (currentTime - blockingAtkMotionStart > 200) {
    setServoAngle(SERVO_TANGANKIRI, 70); 
    setServoAngle(SERVO_PINGGANG, 10);
    Serial.println("BlockingAtkMotion");
    delay(50);
  } 
  if (currentTime - blockingAtkMotionStart > 400) {
    setIdlePosition();
    blockingAtkMotionActive = false;
  }
}

void handleDefeat() {
  robotAlive = false;
  if (client.connected()) {
    client.print(clientName + " defeated!\n");
  }
  defeatAnimationStep = 0;
  defeatMotionStart = millis();
  displayPrint("DEFEATED!\nHold reset");
}

void handleDefeatMotion() {
  switch(defeatAnimationStep) {
    case 0:
      setServoAngle(SERVO_PINGGANG, 20);
      setServoAngle(SERVO_TANGANKIRI, 140);
      setServoAngle(SERVO_SIKUKANAN, 80);
      if(millis() - defeatMotionStart > 1000) {
        defeatAnimationStep = 1;
        defeatMotionStart = millis();
      }
      break;
  }
}

void checkReset() {
  static unsigned long resetStart = 0;

  if (digitalRead(resetPin) == LOW) {
    if (resetStart == 0) {
      resetStart = millis();
    } 
    else if (millis() - resetStart > 5000) {
      hp = hpstats;
      energy = energyMax;
      robotAlive = true;
      defeatAnimationStep = 0;
      isAttacking = false;
      isBlocking = false;
      isHitAnimating = false;
      blockingAtkMotionActive = false;
      setIdlePosition();
      
      if (!client.connected() && serverFound) {
        connectToServer();
      }

      displayPrint("Reboot Complete!");
      Serial.println("System Reset!");
      delay(1500);
      resetStart = 0;
    }
  } 
  else {
    resetStart = 0;
  }
}

void sendAttack() {
  if (!client.connected()) {
    Serial.println("Not connected to server!");
    return;
  }
  
  int totalAtk = atk + (atk * strength / 100);
  String msg = "Atk " + String(totalAtk) + "\n";
  client.print(msg);
  Serial.println("Attack Sent: " + msg);
}

void BlockState() {
  static unsigned long lastEnergyDrain = 0;
  block_state = digitalRead(blockPin);
  
  if (block_state ==  LOW && !isBlocking && energy > 0) {
    isBlocking = true;
    energy = max(energy - 1, 0);
    lastBlockTime = millis();
    Serial.println("Blocking...");
  }

  if (isBlocking && energy > 0) {
    if (millis() - lastEnergyDrain > 1000) {
      lastEnergyDrain = millis();
    }
    unsigned long currentTime = millis();
    isBlocking = true;
    if (currentTime - lastBlockTime < 400) {
      setServoAngle(SERVO_TANGANKIRI,90);
      setServoAngle(SERVO_PINGGANG, 20);
      setServoAngle(SERVO_BAHUKANAN, 150);
      setServoAngle(SERVO_SIKUKANAN, 120);
      delay(50);
    } else {
      isBlocking = false;
    }
  }
}

void setIdleAnimation() {
  static unsigned long idleStartTime = 0;

  if (digitalRead(atkPin) == LOW || digitalRead(blockPin) == LOW 
      || isAttacking || isHitAnimating || blockingAtkMotionActive) {
    idleStartTime = 0;
    return;
  }

  if (idleStartTime == 0) {
    idleStartTime = millis();
  }

  if (millis() - idleStartTime >= 2000) {
    static unsigned long lastUpdateTime = 0;
    const unsigned long updateInterval = 5;
    static int offset = 0;
    static int step = 1;

    if (millis() - lastUpdateTime >= updateInterval) {
      lastUpdateTime = millis();
      offset += step;
      if (offset >= 5 || offset <= -5) {
        step = -step;
      }
      setServoAngle(SERVO_BAHUKANAN, 80 + offset);
      setServoAngle(SERVO_PUNGGUNG, 75 + offset);
      setServoAngle(SERVO_SIKUKANAN, 60 + offset);
      setServoAngle(SERVO_PINGGANG, 40 + offset);
      setServoAngle(SERVO_TANGANKIRI, 110 + offset);
    }
  }
}

void handleAtkState() {
  if (isBlocking) {
    Serial.println("Cannot attack while blocking.");
    return;
  }
  
  static int animationIndex = 0;
  button_state = debounceButton(atkPin);

  if (button_state == LOW && !isAttacking) {
    if (!isBlocking && digitalRead(atkPin) == LOW && atkReleased) {
      isAttacking = true;
      if (millis() - lastAttack > 1000 && energy >= 10) {
        sendAttack();
        energy = max(energy - 5, 0);
        lastAtkTime = millis();
        Serial.println("Attack started.");
        atkReleased = false;
      }
    }
  }
  
  if (isAttacking) {
    unsigned long currentTime = millis();
    switch (animationIndex) {
      case 0:
        if (currentTime - lastAtkTime < 200) {
          setServoAngle(SERVO_PINGGANG, 120);
          setServoAngle(SERVO_PUNGGUNG, 50);
          setServoAngle(SERVO_BAHUKANAN, 150);
          setServoAngle(SERVO_SIKUKANAN, 80);
        } else if (currentTime - lastAtkTime < 500) {
          setServoAngle(SERVO_PINGGANG, 20);
          setServoAngle(SERVO_PUNGGUNG, 50);
          setServoAngle(SERVO_BAHUKANAN, 40);
          setServoAngle(SERVO_SIKUKANAN, 90);
        } else {
          isAttacking = false;
          animationIndex = (animationIndex + 1) % 3;
          setIdlePosition();
          Serial.println("Attack 1 ended.");
          delay(50);
          atkReleased = true;
        }
        break;

      case 1:
        if (currentTime - lastAtkTime < 200) {
          setServoAngle(SERVO_PINGGANG, 20);
          setServoAngle(SERVO_PUNGGUNG, 50);
          setServoAngle(SERVO_BAHUKANAN, 90);
          setServoAngle(SERVO_SIKUKANAN, 90);
        } else if (currentTime - lastAtkTime < 500) {
          setServoAngle(SERVO_PUNGGUNG, 50);
          setServoAngle(SERVO_PINGGANG, 120);
          setServoAngle(SERVO_BAHUKANAN, 140);
          setServoAngle(SERVO_SIKUKANAN, 90);
        }
        else {
          isAttacking = false;
          animationIndex = (animationIndex + 1) % 3;
          setIdlePosition();
          Serial.println("Attack 2 ended.");
          delay(50);
          atkReleased = true;
        }
        break;

      case 2:
        if (currentTime - lastAtkTime < 200) {
          setServoAngle(SERVO_PINGGANG, 60);
          setServoAngle(SERVO_SIKUKANAN, 90);
        } else if (currentTime - lastAtkTime < 400) {
          setServoAngle(SERVO_PINGGANG, 120);
          setServoAngle(SERVO_PUNGGUNG, 40);
          setServoAngle(SERVO_BAHUKANAN, 100);
          setServoAngle(SERVO_SIKUKANAN, 90);
        }
        else {
          isAttacking = false;
          animationIndex = (animationIndex + 1) % 3;
          setIdlePosition();
          Serial.println("Attack 3 ended.");
          delay(50);
          atkReleased = true;
        }
        break;
    }
  }
  else {
    setIdlePosition();
    setIdleAnimation();
  }
}

void loop() {
  checkReset();

  if (!robotAlive) {
    handleDefeatMotion();
    checkReset();
    handleServer();
    updateDisplay();
    return;
  }
  
  handleEnergy();

  if (isHitAnimating) {
    handleHitMotion();
  }

  handleServer();
  updateDisplay();
  handleAtkState();
  BlockState();
}
